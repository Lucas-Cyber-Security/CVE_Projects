# CVE-2025-64459 — Django ORM Injection

This is my walkthrough for CVE-2025-64459. I tested everything inside TryHackMe’s vulnerable Django lab environment. All testing stayed inside the sandbox — nothing on real systems.

---

## Overview

This vulnerability happens when an app takes user request parameters and unpacks them directly into Django ORM filters, like:
```
(User.objects.filter(**request.GET.dict()))
```
Before the fix, Django didn’t stop two internal ORM keys from being passed in:

- _connector — controls how conditions are joined (AND / OR)
- _negated — flips a filter’s logic

If a user can control those, they can rewrite how the whole query works, basically turning secure filters into whatever they want. Django patched this by blocking those internal keys from being set through external input.

---

## How I tested it through TryHackMe

My steps:

1. Start the AttackBox
2. Start the target VM
3. Wait until the web app comes online
4. Open the vulnerable app at a private hosted website


The backend logic basically does this:

1. Reads every query param into a Python dict  
2. Adds defaults if the user didn't specify them  
   - is_published=True  
   - id__lt=10  
3. Passes the entire dictionary into a Q() object  
4. Uses that Q object inside a filter() call

The issue is Step 3 — Q(**query_params).  
Everything the user provides becomes part of the Q object, including internal keys.

---

## Normal query params (baseline testing)

The app accepts standard Django filter syntax:

- ?title=Some Title  
- ?author=Some Author  
- ?title__icontains=draft  
- ?created_date__year=2024  

These work exactly how Django filtering normally works and help confirm the application’s expected behavior.

---

# How the Exploit Works

This is the core of the vulnerability: **you don’t inject SQL directly** — instead, you inject **query logic** at the Django ORM layer.

## 1. How Django normally builds queries

A call like:

    Post.objects.filter(title="Test", is_published=True)

is internally represented as a Q object:

    Q(title="Test") AND Q(is_published=True)

The ORM then turns that into SQL.

---

## 2. What _connector and _negated do

Inside Django, Q objects contain:

- a list of conditions  
- a connector (default = AND)  
- a negated flag (default = False)

Example of internal representation:

    Q(title="Test", is_published=True)
        .connector = "AND"
        .negated = False

If someone changes connector to OR:

    Q(title="Test", is_published=True, _connector="OR")

this becomes:

    title="Test" OR is_published=True

And if they negate the whole thing:

    NOT (title="Test" AND is_published=True)

Those internal parameters should NEVER be controlled by the user.

---

## 3. Why the exploit works

The vulnerable application takes **all** request parameters and dumps them into the Q constructor:

    q_filter = Q(**query_params)

If an attacker supplies:

    _connector=OR 1=1 OR

the ORM tries to set:

    q_filter.connector = "OR 1=1 OR"

Django’s SQL compiler then builds something like:

    WHERE (title = "X") OR 1=1 OR (is_published=True)

**Now every row matches**, because 1=1 always evaluates to true.

Even though Django escapes field values, this field (connector) gets inserted directly into SQL keywords, not user-controlled value space.

---

# Step-by-Step Exploitation in This Lab

Here’s how I exploited it inside TryHackMe.
These steps cannot be recreated by an external user since it is based on my Tryhackme account.

### 1. Confirm normal filtering works

http://website_IP:8000/poc/?author=Security%20Architect

Using this link changes the display of the test website, meaning actions can be performed and confirms an exploit is available. 

---

### 2. Inject a malicious connector

To force the app to return **every** post:

http://website_IP:8000/poc/?author=Security%20Architect&_connector=OR%201=1%20OR

What happens internally:

1. Django receives parameters:  
   - author="Security Architect"  
   - _connector="OR 1=1 OR"

2. Backend constructs:  
   Q(author="Security Architect", _connector="OR 1=1 OR")

3. ORM builds SQL:  
   (author="Security Architect") OR 1=1 OR (is_published=True)

4. 1=1 triggers a full match

The result:  
**Every post in the database shows up**, including unpublished ones.

This is a form of **data exfiltration using ORM logic manipulation**.

---

### 3. Employee dataset example

Employee listing is here:

http://website_IP:8000/poc/employees

To find the employee hired on June 5, 2022:

http://website_IP:8000/poc/employees?hire_date_year=2022&is_active=false

Same principle: you can filter normally or override logic using the same exploit.

---

# Why this Vulnerability Is Dangerous

- No SQL injection needed — the ORM does the dangerous part  
- Traffic looks “normal” because parameters look like typical Django keys  
- Attacks can modify logic silently  
- Can bypass authentication, authorization checks, or access controls  
- Works with GET parameters, so it's easy to script or automate  
- Many developers trust ORM filtering too much and think it’s “safe by default”

---

## Mitigation

To fix this:

- Update Django to the patched version
- Block internal fields (_connector, _negated) at the app layer or a WAF
- Whitelist allowed fields before expanding user input into filters
- Avoid unpacking raw request data directly into ORM filter(**kwargs)

---

## What I learned

- ORMs can still be abused even without raw SQL injection
- Changing query logic (AND→OR, negation) can leak data the same way SQLi does
- These attacks blend in with normal traffic unless you're watching for internal parameter names
- TryHackMe makes it easy to safely explore CVEs end-to-end

---

## Folder structure

- README.md — main write-up  
- screenshots/

---
 
